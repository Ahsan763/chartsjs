<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

</head>

<body>
  <section class="mapSection">
    <div class="container">
      <h2 class="mapSection__heading">Evolution of AI</h2>
      <p class="mapSection__span">1950 - Future</p>
      <img src="downarrow.svg" alt="" class="mapSection__img">
      <div class="relative">
        <div class="relative__border"></div>
        <canvas id="aiChart"></canvas>
      </div>
    </div>
  </section>
  <script>
    const taglines = {
      1950: 'AI conceptualized as machines that can think.',
      1960: 'Emergence of symbolic AI and early programs.',
      1970: 'AI Winter halts development of AI after early boom.',
      1975: 'New optimism with expert systems.',
      2000: 'Machine learning begins to rise.',
      2010: 'Deep learning breakthroughs fuel AI advancements.',
      2020: 'AI impacts daily life with automation and predictions.',
      2030: 'AI predicted to surpass human-level intelligence.'
    };

    const ctx = document.getElementById('aiChart').getContext('2d');
    let chart;

    const chartOptions = {
      responsive: true,
      plugins: {
        legend: { display: false },
        tooltip: {
          enabled: false,
          external: externalTooltipHandler
        }
      },
      scales: {
        x: {
          type: 'linear',
          ticks: {
            color: 'white',
            padding: 40
          },
          grid: {
            drawOnChartArea: false,
            drawTicks: false,
            min: 1945,
            max: 2035,
          }
        },
        y: {
          display: false
        }
      }
    };

    function createChart() {
      chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [1950, 1960, 1970, 1980, 1990, 2000, 2010, 2020, 2030],
          datasets: [{
            label: 'AI Evolution',
            data: [
              { x: 1950, y: 0 },
              { x: 1970, y: 0.3 },
              { x: 1990, y: 1.4 },
              { x: 2005, y: 3 },
              { x: 2020, y: 6 },
              { x: 2030, y: 9.6 }
            ],
            borderColor: 'cyan',
            tension: 0.4,
            borderWidth: 2,
            pointBackgroundColor: 'black',
            pointBorderColor: 'cyan',
            pointBorderWidth: 2,
            pointRadius: 5,
            pointHoverBackgroundColor: 'cyan',
            pointHoverBorderColor: 'rgba(14, 230, 255, 0.6)',
            pointHoverBorderWidth: 6,
            pointHoverRadius: 5,
          }]
        },
        options: chartOptions
      });
    }
    function externalTooltipHandler(context) {
      // Tooltip Element
      let tooltipEl = document.getElementById('chartjs-tooltip');
      if (!tooltipEl) {
        tooltipEl = document.createElement('div');
        tooltipEl.id = 'chartjs-tooltip';
        document.body.appendChild(tooltipEl);
      }

      // Hide tooltip when no active elements
      const tooltipModel = context.tooltip;
      if (tooltipModel.opacity === 0) {
        tooltipEl.style.opacity = '0';
        return;
      }

      // Set Text
      if (tooltipModel.body) {
        const dataPoint = tooltipModel.dataPoints[0];
        const year = dataPoint.raw.x;
        tooltipEl.innerHTML = `
    <div style="font-size: 24px; font-weight: bold; color: cyan;">
        ${year}s
    </div>
    <div>${taglines[year] || 'No data available'}</div>`;
      }

      // Positioning
      const position = context.chart.canvas.getBoundingClientRect();
      const bodyFont = Chart.helpers.toFont(tooltipModel.options.bodyFont);

      // Calculate tooltip position
      let left = position.left + window.pageXOffset + tooltipModel.caretX - 150; // Center tooltip
      let top = position.top + window.pageYOffset + tooltipModel.caretY - 100; // 100px above the point

      // Adjust horizontal positioning to ensure tooltip doesn't go off-screen
      const tooltipWidth = 300; // Width of the tooltip
      const windowWidth = window.innerWidth;

      if (left + tooltipWidth > windowWidth - 60) { // Changed from 10 to 60 to add more space
        left = windowWidth - tooltipWidth - 60; // Ensure the tooltip stays within the right edge with extra space
      }

      if (left < 10) {
        left = 10; // Ensure the tooltip doesn't go off the left edge
      }

      // Display, position, and set styles for font
      tooltipEl.style.opacity = '1';
      tooltipEl.style.position = 'absolute';
      tooltipEl.style.left = `${left}px`;
      tooltipEl.style.top = `${top}px`;
      tooltipEl.style.font = bodyFont.string;
      tooltipEl.style.padding = `${tooltipModel.padding}px`;
      tooltipEl.style.pointerEvents = 'none';
    }

    // function externalTooltipHandler(context) {
    //   // Tooltip Element
    //   let tooltipEl = document.getElementById('chartjs-tooltip');
    //   if (!tooltipEl) {
    //     tooltipEl = document.createElement('div');
    //     tooltipEl.id = 'chartjs-tooltip';
    //     document.body.appendChild(tooltipEl);
    //   }

    //   // Hide tooltip when no active elements
    //   const tooltipModel = context.tooltip;
    //   if (tooltipModel.opacity === 0) {
    //     tooltipEl.style.opacity = '0';
    //     return;
    //   }

    //   // Set Text
    //   if (tooltipModel.body) {
    //     const dataPoint = tooltipModel.dataPoints[0];
    //     const year = dataPoint.raw.x;
    //     tooltipEl.innerHTML = `
    //         <div style="font-size: 24px; font-weight: bold; color: cyan;">
    //             ${year}s
    //         </div>
    //         <div>${taglines[year] || 'No data available'}</div>`;
    //   }

    //   // Positioning
    //   const position = context.chart.canvas.getBoundingClientRect();
    //   const bodyFont = Chart.helpers.toFont(tooltipModel.options.bodyFont);

    //   // Calculate position
    //   let left = position.left + window.pageXOffset + tooltipModel.caretX;
    //   // let top = position.top + window.pageYOffset + tooltipModel.caretY;

    //   // Adjust position if tooltip goes off-screen
    //   const tooltipWidth = 300; // Width of the tooltip
    //   // const tooltipHeight = 150; // Approximate height of the tooltip
    //   const windowWidth = window.innerWidth;

    //   if (left + tooltipWidth > windowWidth) {
    //     left = windowWidth - tooltipWidth - 70; // 10px padding from the right edge
    //   }

    //   // if (top + tooltipHeight > windowHeight) {
    //   //   top = windowHeight - tooltipHeight + 300; // 10px padding from the bottom edge
    //   // }

    //   // Display, position, and set styles for font
    //   tooltipEl.style.opacity = '1';
    //   tooltipEl.style.position = 'absolute';
    //   tooltipEl.style.left = left + 'px';
    //   // tooltipEl.style.top = '0';
    //   tooltipEl.style.font = bodyFont.string;
    //   tooltipEl.style.padding = tooltipModel.padding + 'px ' + tooltipModel.padding + 'px';
    //   tooltipEl.style.pointerEvents = 'none';
    // }

    function updateChartOptions() {
      if (!chart) return;

      if (window.innerWidth <= 430) {
        // For screens <= 430px
        chartOptions.scales.x.ticks.padding = 10; // Smallest padding
        chart.data.datasets[0].pointRadius = 2; // Smallest dot size
        chart.data.datasets[0].pointHoverRadius = 3; // Small hover dot size
      } else if (window.innerWidth <= 767) {
        // For screens between 431px and 767px
        chartOptions.scales.x.ticks.padding = 23; // Medium padding
        chart.data.datasets[0].pointRadius = 3; // Medium dot size
        chart.data.datasets[0].pointHoverRadius = 4; // Medium hover dot size
      } else {
        // Default for larger screens
        chartOptions.scales.x.ticks.padding = 40; // Default padding
        chart.data.datasets[0].pointRadius = 5; // Default dot size
        chart.data.datasets[0].pointHoverRadius = 5; // Default hover dot size
      }
      // Re-assign the updated options to the chart and update
      chart.options = chartOptions;
      chart.update();
    }

    // Create the chart when the page loads
    window.addEventListener('load', createChart);

    // Apply changes on window resize
    window.addEventListener('resize', updateChartOptions);

    // Initial call to set options based on current screen size
    window.addEventListener('load', updateChartOptions);


  </script>
  <!-- <script>

    const taglines = {
      1950: 'AI conceptualized as machines that can think.',
      1960: 'Emergence of symbolic AI and early programs.',
      1970: 'AI Winter halts development of AI after early boom.',
      1975: 'New optimism with expert systems.',
      2000: 'Machine learning begins to rise.',
      2010: 'Deep learning breakthroughs fuel AI advancements.',
      2020: 'AI impacts daily life with automation and predictions.',
      2030: 'AI predicted to surpass human-level intelligence.'
    };

    const ctx = document.getElementById('aiChart').getContext('2d');
    // Default options
    let chartOptions = {
      responsive: true,
      plugins: {
        legend: { display: false },
        // tooltip: {
        //   boxWidth: 40,
        //   titleColor: 'cyan',
        //   backgroundColor: '#333',
        //   titleFont: {
        //     size: 24,
        //     weight: 'bold',
        //     family: "'Helvetica', sans-serif",
        //   },
        //   bodyFont: {
        //     size: 12,
        //     family: "'Helvetica', sans-serif",
        //   },
        //   padding: 20,
        //   cornerRadius: 10,
        //   displayColors: false,
        //   outerWidth: 40,
        //   yAlign: 'bottom',
        //   xAlign: 'center',
        //   caretPadding: 25, // Add more offset between tooltip and dot
        //   callbacks: {
        //     title: function (context) {
        //       return context[0].label + 's';
        //     },
        //     label: function (tooltipItem) {
        //       const year = tooltipItem.raw.x;
        //       return taglines[year] || 'No data available';
        //     }
        //   }
        // }

        tooltip: {
          enabled: false, // Disable the default tooltip
          external: function (context) {
            // Tooltip Element
            let tooltipEl = document.getElementById('chartjs-tooltip');
            if (!tooltipEl) {
              tooltipEl = document.createElement('div');
              tooltipEl.id = 'chartjs-tooltip';
              tooltipEl.style.background = '#333';
              tooltipEl.style.borderRadius = '10px';
              tooltipEl.style.color = 'white';
              tooltipEl.style.opacity = 1;
              tooltipEl.style.pointerEvents = 'none';
              // tooltipEl.style.position = 'absolute';
              // tooltipEl.style.transform = 'translate(-50%, -100%)';
              tooltipEl.style.transition = 'opacity 0.2s ease';
              tooltipEl.style.padding = '10px 15px';
              tooltipEl.style.fontFamily = "'Helvetica', sans-serif";
              tooltipEl.style.fontSize = '12px';
              tooltipEl.style.width = '300px';
              tooltipEl.style.textAlign = 'center';
              document.body.appendChild(tooltipEl);
            }

            // Hide tooltip when no active elements
            const tooltipModel = context.tooltip;
            if (tooltipModel.opacity === 0) {
              tooltipEl.style.opacity = 0;
              return;
            }

            // Set Text
            if (tooltipModel.body) {
              const dataPoint = tooltipModel.dataPoints[0];
              const year = dataPoint.raw.x;
              tooltipEl.innerHTML = `
            <div style="font-size: 24px; font-weight: bold; color: cyan;">
              ${year}s
            </div>
            <div>${taglines[year] || 'No data available'}</div>`;
            }

            // Positioning
            const position = context.chart.canvas.getBoundingClientRect();
            const bodyFont = Chart.helpers.toFont(tooltipModel.options.bodyFont);

            // Display, position, and set styles for font
            tooltipEl.style.opacity = 1;
            tooltipEl.style.position = 'absolute';
            tooltipEl.style.left = position.left + window.pageXOffset + tooltipModel.caretX + 'px';
            tooltipEl.style.top = position.top + window.pageYOffset + tooltipModel.caretY + 'px';
            tooltipEl.style.font = bodyFont.string;
            tooltipEl.style.padding = tooltipModel.padding + 'px ' + tooltipModel.padding + 'px';
            tooltipEl.style.pointerEvents = 'none';
          }
        }
      },
      scales: {
        x: {
          type: 'linear',
          ticks: {
            color: 'white',
            padding: 40
          },
          grid: {
            drawOnChartArea: false,
            drawTicks: false,
            min: 1945,
            max: 2035,
          }
        },
        y: {
          display: false
        }
      }
    };
    // Initialize Chart.js
    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [1950, 1960, 1970, 1980, 1990, 2000, 2010, 2020, `hjhjhjh`],
        datasets: [{
          label: 'AI Evolution',
          data: [
            { x: 1950, y: 0 },
            // { x: 1960, y: 0.6 },
            { x: 1970, y: 0.3 },
            // { x: 1980, y: 2.5 },
            { x: 1990, y: 1.4 },
            { x: 2005, y: 3 },
            // { x: 2010, y: 9 },
            { x: 2020, y: 6 },
            { x: 2030, y: 9.6 }
          ],
          borderColor: 'cyan',
          tension: 0.4,
          borderWidth: 2,
          pointBackgroundColor: 'black',
          pointBorderColor: 'cyan',
          pointBorderWidth: 2,
          pointRadius: 30,
          pointHoverBackgroundColor: 'cyan',
          pointHoverBorderColor: 'rgba(14, 230, 255, 0.6)',
          pointHoverBorderWidth: 6,
          pointHoverRadius: 1,
        }]
      },
      options: chartOptions
    });
    // Function to update dot size and padding dynamically
    function updateChartOptions() {
      if (window.innerWidth <= 430) {
        // For screens <= 430px
        chartOptions.scales.x.ticks.padding = 10; // Smallest padding
        chart.data.datasets[0].pointRadius = 2; // Smallest dot size
        chart.data.datasets[0].pointHoverRadius = 3; // Small hover dot size
      } else if (window.innerWidth <= 767) {
        // For screens between 431px and 767px
        chartOptions.scales.x.ticks.padding = 23; // Medium padding
        chart.data.datasets[0].pointRadius = 3; // Medium dot size
        chart.data.datasets[0].pointHoverRadius = 4; // Medium hover dot size
      } else {
        // Default for larger screens
        chartOptions.scales.x.ticks.padding = 40; // Default padding
        chart.data.datasets[0].pointRadius = 5; // Default dot size
        chart.data.datasets[0].pointHoverRadius = 5; // Default hover dot size
      }
      // Re-assign the updated options to the chart and update
      chart.options = chartOptions;
      chart.update();
    }
    // Apply changes on window resize
    window.addEventListener('resize', () => {
      updateChartOptions();
    });
    // Initial call to set options based on current screen size
    updateChartOptions();
  </script> -->
</body>

</html>